#### 1、为什么使用redis

首先我们用redis来保证数据持久化，和不同服务之间共享数据，我们利用redis得list得数据结构得左近右出来保证越早生成得任务能够先有优先执行权，我们目前接入38家医院调度得任务有，datax采集任务，文件下载，影像采集，影像打包，影像下载等，一个调度大概qps能达到100多，所以同时调度时得qps有5-6百，为了避免频繁得对数据库操作所以我们将这些数据缓存在redis中来减少对数据库得压力

#### 2、推和拉各自得优缺点

- push
  - 优点：消息能够及时推送到客户端延迟小
  - 缺点：当客户端消费能力不足的时候可能造成消息堆积，不同客户端消费能力不一样，如果服务端以相同数量居
- pull
  - 优点：根据消费者得能力进行自主消费
  - 缺点：就是每次拉得间隔时间需要多少，太短得话可能造成空轮询，太长消息没有办法及时消费，有一点得延时消费

#### 3、Kafka和其他MQ作比较为什么选Kafka他的优势在哪里

- ActiveMQ吞吐量较低，有可能丢失消息得风险
- RabbitMQ吞吐量低，erlang语言实现，不好进行进一步开发扩展。
- RocketMQ简单易用，怕万一不维护了需要自己公司研发
- kafka具有低延迟，高吞吐，高可用，和拓展性比较好，有可能重复消费得可能

#### 4、Netty 为什么快

Netty主要是对NIO得封装，采用了同步非阻塞方式进行传输所以在传输过程中比以往得阻塞式IO更快，零拷贝减少了内核去用户内存得上下文切换，NIO主要请求交给Selectot来处理，Selectot遍历所有Socket，当有Socket进来得时候交给Thread 处理

#### 5、Netty 3、4 、5有什么区别

Netty 3，read（I/O线程）和write（业务线程来操作Handler）由不同线程来操作会存在上下文切换

Netty4，读和写都是用EventLoop来串行进行调度，不需要上下文的切换，如果由某个Handler执行时间较长的话会使整体链路的效率降低

Netty5,

#### 6、AOP原理

aop主要是利用动态代理，来实现代理的前置处理和后置处理，主要源码体现实在DI的过程中对象实例化后调用后置处理器，如果当前是个接口则使用JDK动态代理，否则使用CGLIB，最后通过JDKProxy的invok方法通过反射的方式调用被代理类的方法

#### 7、7和8 jvm得区别，各自得垃圾回收器得优缺点，和使用场景

7-8主要用元空间替换永久代，永久代将方法去放在jvm内存，元空间交予系统内存处理减少了配置jvm内存和OOM的风险

垃圾回收算法主要有

标记复制算法，主要用于新生代，因为新生代可以通过S1和S0作为中介来进行复制，主要原因时Yange GC 比较频繁

标记清除，会造成大量的空间碎片

标记整理比较耗时主要用于老年代Full GC 没有那么频繁

Serial，Serial Old主要用于单核的服务器

ParNew，Parallel Scavenge，Parallel Old  主要追求吞吐量

CMS，G1 主要追求停顿时间，G1可配置回收时间

#### 8、mybatis 原理

mybatis主要运用的大量的动态代理，容器启动的时候会解析配置文件将信息保存Configuration，当调用mapper接口的时候，其实是个代理类回去SqlSession的Configuration获取对应的Sement，然后解析Sql并执行然后放回pojo

#### 9、如何解决慢sql

首先看执行计划是否用到了全表扫描，如过全表扫描尝试加索引看下效率是否能够提升，是否有多个关联查询，能否加些冗余字段来避免过多得关联，数据量是否过大，可以考虑分表，如果是历史数据不需要用到考虑将表归档

#### 10、dubbo得特性

实现RPC 调用，支持多协议，并发高性能，负载均衡，高可用，容错，支持配置功能（白名单）

#### 11、dubbo的原理

服务端启动的时候会将服务的配置信息比如接口信息，使用的协议之类的注册到注册中心，客户端启动的时候会去配置中心获取接口配置，单调用接口的时候使用动态代理的方式获取方法的名称来获取接口下可连接的服务来进行负载均衡调用

#### 12、ThreadLocal

ThreadLocal主要用并发安全问题，每个线程都有维护一个ThreadLocal，ThreadLocal里有个ThreadLocalMap来保存对象，ThreadLocal主要的风险是再使用完需及时remove如果不remove可能线程被重复使用的时候导致脏数据，ThreadLocalMap的entry继承了软引用，保证每次GC的时候对象能被回收，避免了OOM的风险

#### 13、和领导意见不统一时你会怎么做

首先先看这个问题是什么如果是技术选型的话，可以通过一些测试数据来证明哪种方案比较好，如果是策略的话看下网上是否有别人用过的案例，看别人是怎么做的别人用了这个方案踩了什么坑等。

#### 14、和同事意见不统一时

首先先讲下双方的想法，优缺点，如果内部能消化最好，大部分内部都能选出较好的方案，如果还是选不出的话，可以叫同事一起进行讨论看看别人的意见，可能会有第三种更好的方案。

#### 15、在你目前基础上提出3点来提高今后得代码质

- 多了解一些底层的源码，了解一些JDK的API的原理，和各自的优缺点，还有一些新的API的使用
- 目前有做到会反复的看代码并重构，如果觉得比较麻烦的我可能会先放那，今后提高一下自我的执行力来重构一些比较繁琐的代码
- 再设计模式还没吃透的部分将他吃透