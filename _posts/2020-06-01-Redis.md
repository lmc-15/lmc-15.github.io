### LUA

lua优点：

- 一次性发送多个命令，减少网络开销
- 不会被其他请求打断，保证原子性
- 复杂命令写在文件中，实现程序之间命令集复用

lua缓存：

- 调用时把脚本传到Redis服务端产生较大的网络开销，所以在脚本比较稳定，和脚本较大的情况，允许开发者通过脚本内容的SHA1摘要来执行脚本。

### Redis为什么这么块

#### 内存

- KV结构的内存数据库，时间复制度O(1)

#### 单线程

- 没有创建线程，销毁线程带来的消耗
- 避免了上下文切换导致的CPU消耗
- 避免线程之间的竞争，带来的加锁，释放锁，死锁等问题

#### 异步非阻塞

- 异步非阻塞I/O，多路复用处理并发连接。

### 单线程为什么这么块

redis的瓶颈不在CPU，Redis的瓶颈在于机器内存和网络带宽。当线程实现比较容易，所以redis就采用了单线程方案。

### 内存回收

#### 1、过期策略

- 定时过期（主动淘汰）

  设置过期时间key设置定时器，到过期时间立即清楚，对内存友好，但是占用大量cpu资源处理过期数据，影响缓存的响应时间和吞吐量。

- 惰性过去（被动淘汰）

  当访问Key时判断key是否已经过期，过期则清楚。对CPU友好，对内存非常不友好，可能出现大量的key没有再次 被访问，从而不会被清除，占用大量内存。

- 定期过期

  每隔一定时间，扫描数据库字典中一定的数量key，并清楚过去的key

#### 2、lru淘汰原理

- 淘汰` 热度最低`的key(默认是5个)
- redis对象结构有lru字段用来记录对象的热度，被访问时更新lru值

#### 3、lfu

- 高16位用来记录访问时间
- 低8问用来记录访问频率
- 如果没有被访问访问频率随着时间增加而减少每分钟递减1

### 持节化

#### RDB

redis默认的持久化方案，满足一定条件的时候，会把当前内存中数据生成快照写入磁盘dump.rdb,重启redis加载dump.rdb文件恢复数据.

##### 1、RDB触发

- 自动触发

  - save 900 1 # 900 秒内至少有一个key 被修改（包括添加）
  - save 300 10 # 300 秒内至少有10 个key 被修改
  - save 60 10000 # 60 秒内至少有10000 个key 被修改

- 手动触发

  - save 

    不建议使用,会阻塞当前redis服务器,redis不能执行其他命令

  - bgsave 

    执行bgsave时,redis会在后台异步进行快照操作,同时还可以相应客户端请求.\

##### 2、RDB优略势

- 优势
  - 文件紧凑,保存某个时间点的数据,适用备份和灾难恢复
  - 生成RDB时,redis主进程会fork()子进程来保存工作,主进程不需要任何磁盘IO操作
  - RDB恢复大数据时速度比AOF的恢复速度快.
- 劣势
  - 没办法做到实时持久化,每次操作` bgsave`都会fork创建子进程,频繁执行成本过高.
  - 间隔时间做一次备份,redis意外down掉的话,会丢失最后一次快照的所有修改

#### AOF

redis 默认不开启.aof每个写操作,追加到文件中.执行更改reids数据的命令时,把命令写入AOF文件中.

重启时根据日志内容重新执行一遍

##### 1、AOF文件压缩

当AOF文件的大小超过阈值时,Redis就会启动AOF文件内容压缩,保留恢复数据的最小指令集.

##### 2、AOF优略势

- 优势
  - AOF 持久化的方法提供了多种的同步频率，即使使用默认的同步频率每秒同步一次，Redis 最多也就丢失1 秒的数据而已。
- 劣势
  - AOF文件较大
  - 高并发时RDB比AOF具有更好的性能保证.



### Redis主从复制

从节点不能写入数据(只读),从mastre节点同步数据。主节点写入后，slave会自动从master同步数据。

#### 1、主从复制原理

- 连接阶段
  - ` slave node`启动时（执行slaveof 命令）,会在本地保存` master node`信息，包括 host 和ip
  - ` slave node`通过replicatationCron，没一秒检查` master node`是否连接成功,如果连接成功，从节点通过socket来专门处理工作文件，负责后续的复制工作，如RDB文件，接收命令传播等。

- 数据同步阶段
  - master接收到`slave node`命令后，通过bgsave生成一份RDB快照，将` RDB快照文件`发送给slave node，超时则选择重试
  - slave node 先清除自身的旧数据，再用`RDB文件`来加载数据。
  - 新的命令进来，master会把新的写命令缓存起来，`slave node`保存RDB之后,再将写命令复制给slave node
  - 先尝试增量同步，不成功，要求` slave node` 进行全量
  - 

### 可用性Sentinel（哨兵）

#### 1、服务下线

- **Sentinel**每秒往Redis服务节点发送Ping命令。down-after-milliseconds 内都没有收到有效回复，Sentinel 会将该服务器标记为下线（主观下线）。
- 这个**Sentinel**会询问其他节点，如果多数**Sentinel**节点都认为**master**下线，该**master**将被认为(客观下线)，需重新选举**master**

#### 2、故障转移

- 多个**Sentinel**选择一个来当**Leader**，**Sentinle **通过`Raft `算法，实现**Sentinle **选举。

#### 3、Raft算法

- `raft`是一个共识算法（consensus algorithm），就是多个节点对某个事情目标达成一致的看法。
- 如果在选举超时周期内没有收到AppendEntries的请求或者给Candidate投票，转换为Candidate角色*Candidates*
- 转换为candidate角色，开始选举：
  - 递增currentTerm
  - 给自己投票
  - 重置选举时间
  - 发送RequestVote给其他所有节点
- 如果收到了大多数节点的选票，转换为Leader节点
- 如果收到Leader节点的AppendEntries请求，转换为Follower节点
- 如果选举超时，重新开始新一轮的选举

##### *Leaders*

- 一旦选举完成：发送心跳给所有节点；在空闲的周期内不断发送心跳保持Leader身份
- 如果收到客户端的请求，将日志追加到本地log，在日志被应用到状态机后响应给客户端
- 如果对于一个跟随者，最后日志条目的索引值大于等于 nextIndex，那么：发送从 nextIndex 开始的所有日志条目：
  - 如果成功：更新相应跟随者的 nextIndex 和 matchIndex
  - 如果因为日志不一致而失败，减少 nextIndex 重试
  - 如果存在一个满足N > commitIndex的 N，并且大多数的matchIndex[i] ≥ N成立，并且log[N].term == currentTerm成立，那么令commitIndex等于这个N

### Redis分布式

#### 1、Redis  Cluster

- 数据分片几个关键问题解决:
  - 数据如何相对均匀分片
  - 客户端如何访问相应节点和数据
  - 重新分片如何保证服务正常
- 数据如何相对均匀分片
  - **Redis**利用**虚拟槽**来实现。
  - **Redis**创建16384个槽（`slot`）,每个节点负责一定区间的槽。
  - **Redis**的每个`master `节点维护一个16384位
  - 对象分布到**Redis **节点上时，对key 用CRC16 算法计算再%16384，得到一个slot的值，数据落到负责这个slot 的Redis 节点上。

#### 2、数据迁移

- 新增新节点只需把原有的solt分配给新节点负责，并把相关数据迁移过来
- 迁移过程中客户端通过`moved`和`asked`重定向请求找到正确的缓存节点

### 数据结构

- Redis对使用者暴露了五种Value Type, 其底层实现的数据结构有8种, 分别是:
  - SDS - simple synamic string - 支持自动动态扩容的字节数组
  - list - 平平无奇的链表
  - dict - 使用双哈希表实现的, 支持平滑扩容的字典
  - zskiplist - 附加了后向指针的跳跃表
  - intset - 用于存储整数数值集合的自有结构
  - ziplist - 一种实现上类似于TLV, 但比TLV复杂的, 用于存储任意数据的有序序列的数据结构
  - quicklist - 一种以ziplist作为结点的双链表结构, 实现的非常苟
  - zipmap - 一种用于在小规模场合使用的轻量级字典结构
- dict 如何平滑扩容

### 内存淘汰策略

删除已经过期的key

通过lru删除key

通过lru删除带有过期时间的key

通过lfu删除最不常用的key

通过lfu删除带有过期时间最不常用的key

随机删除带有过期时间的key

随机删除key

删除最新过期的key

什么都不做



建议使用在带有过期时间的键中选择最不常用的。

### lru

每个key有个lru字段用来记录访问时间，redis有个全局server.lruclock  值来记录当前unix的时间搓两个值相减相差越大的说明热度越低



### lfu

是由24为字节来维护的，高16为用来记录访问时间，低8为记录访问频率，热度跟访问频率成正比与访问时间差成反比