### LUA

lua优点：

- 一次性发送多个命令，减少网络开销
- 不会被其他请求打断，保证原子性
- 复杂命令写在文件中，实现程序之间命令集复用

lua缓存：

- 调用时把脚本传到Redis服务端产生较大的网络开销，所以在脚本比较稳定，和脚本较大的情况，允许开发者通过脚本内容的SHA1摘要来执行脚本。

### Redis为什么这么块

#### 内存

- KV结构的内存数据库，时间复制度O(1)

#### 单线程

- 没有创建线程，销毁线程带来的消耗
- 避免了上下文切换导致的CPU消耗
- 避免线程之间的竞争，带来的加锁，释放锁，死锁等问题

#### 异步非阻塞

- 异步非阻塞I/O，多路复用处理并发连接。

### 单线程为什么这么块

redis的瓶颈不在CPU，Redis的瓶颈在于机器内存和网络带宽。当线程实现比较容易，所以redis就采用了单线程方案。

### 内存回收

#### 1、过期策略

- 定时过期（主动淘汰）

  设置过期时间key设置定时器，到过期时间立即清楚，对内存友好，但是占用大量cpu资源处理过期数据，影响缓存的响应时间和吞吐量。

- 惰性过去（被动淘汰）

  当访问Key时判断key是否已经过期，过期则清楚。对CPU友好，对内存非常不友好，可能出现大量的key没有再次 被访问，从而不会被清除，占用大量内存。

- 定期过期

  每隔一定时间，扫描数据库字典中一定的数量key，并清楚过去的key

#### 2、lru淘汰原理

- 淘汰` 热度最低`的key(默认是5个)
- redis对象结构有lru字段用来记录对象的热度，被访问时更新lru值

#### 3、lfu

- 高16位用来记录访问时间
- 低8问用来记录访问频率
- 如果没有被访问访问频率随着时间增加而减少每分钟递减1

### 持节化

#### RDB

redis默认的持久化方案，满足一定条件的时候，会把当前内存中数据生成快照写入磁盘dump.rdb,重启redis加载dump.rdb文件恢复数据.

##### 1、RDB触发

- 自动触发

  - save 900 1 # 900 秒内至少有一个key 被修改（包括添加）
  - save 300 10 # 300 秒内至少有10 个key 被修改
  - save 60 10000 # 60 秒内至少有10000 个key 被修改

- 手动触发

  - save 

    不建议使用,会阻塞当前redis服务器,redis不能执行其他命令

  - bgsave 

    执行bgsave时,redis会在后台异步进行快照操作,同时还可以相应客户端请求.\

##### 2、RDB优略势

- 优势
  - 文件紧凑,保存某个时间点的数据,适用备份和灾难恢复
  - 生成RDB时,redis主进程会fork()子进程来保存工作,主进程不需要任何磁盘IO操作
  - RDB恢复大数据时速度比AOF的恢复速度快.
- 劣势
  - 没办法做到实时持久化,每次操作` bgsave`都会fork创建子进程,频繁执行成本过高.
  - 间隔时间做一次备份,redis意外down掉的话,会丢失最后一次快照的所有修改

#### AOF

redis 默认不开启.aof每个写操作,追加到文件中.执行更改reids数据的命令时,把命令写入AOF文件中.

重启时根据日志内容重新执行一遍

##### 1、AOF文件压缩

当AOF文件的大小超过阈值时,Redis就会启动AOF文件内容压缩,保留恢复数据的最小指令集.

##### 2、AOF优略势

- 优势
  - AOF 持久化的方法提供了多种的同步频率，即使使用默认的同步频率每秒同步一次，Redis 最多也就丢失1 秒的数据而已。
- 劣势
  - AOF文件较大
  - 高并发时RDB比AOF具有更好的性能保证.





