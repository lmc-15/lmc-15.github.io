### ReentrantLock

- 先获取stast是否为0，为0则获取锁成功
- 不为0则判断当前线程和获取锁线程是否为同一个线程，是则获取锁成功
- 不是再次尝试获取锁，如果获取不到获取AQS得tail节点通过cas设置当前线程节点得prev节点，并将当前节点设置为tail节点
- 调用LockSupport.unpack()方法将线程挂起

### CyclicBarrier

```java
package com.lmc.juc.cyclicbarrier;

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

/**
 * @Description
 * @Author liumc <liumingchao@cecdat.com>
 * @Since 2020/6/5$
 */
public class DataImportThread extends Thread {
    private CyclicBarrier cyclicBarrier;
    private String path;

    public DataImportThread(CyclicBarrier cyclicBarrier, String path) {
        this.cyclicBarrier = cyclicBarrier;
        this.path = path;
    }

    @Override
    public void run() {
        System.out.println("开始导入" + path + "数据");
        try {
            cyclicBarrier.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (BrokenBarrierException e) {
            e.printStackTrace();
        }
    }
}

```

```java
package com.lmc.juc.cyclicbarrier;

import java.util.concurrent.CyclicBarrier;

/**
 * @Description
 * @Author liumc <liumingchao@cecdat.com>
 * @Since 2020/6/5$
 */
public class CyclicBarrierDemo extends Thread{
    @Override
    public void run() {
        System.out.println("开始进行数据分析");
    }

    public static void main(String[] args) {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(3,new CyclicBarrierDemo());
        new Thread(new DataImportThread(cyclicBarrier,"file1")).start();
        new Thread(new DataImportThread(cyclicBarrier,"file2")).start();
        new Thread(new DataImportThread(cyclicBarrier,"file3")).start();
    }
}

```

- 当调用得线程数没有达到parties时，**CyclicBarrier**会被`await()`
- **CyclicBarrier**可以调用`await(timeout,unit)`设置超时时间，在设定时间没达到线程数也会解除阻塞状态
- 通过reset重置计数，会使得进入await得线程出来，BrokenBarrierExeption；
- 使用new CyclicBarrier(int parties,new Runnable barrierAction)构造方法,执行barrierAction操作得最后一个线程
- 通过ReentrantLock和Condition组合实现
- 当每个**CyclicBarrier**的`await`被执行时计数器减一，当计数器为0时所有**CyclicBarrier**将被唤醒

### 阻塞队列以ArrayBlockingQueue为例

```java
 public void put(E e) throws InterruptedException {
     //校验入队是否为null
        checkNotNull(e);
        final ReentrantLock lock = this.lock;
     //获得锁
        lock.lockInterruptibly();
        try {
            //当队列满了进行阻塞
            while (count == items.length)
                //满阻塞
                notFull.await();
            //节点入队
            enqueue(e);
        } finally {
            lock.unlock();
        }
    }
```

```java
    private void enqueue(E x) {
        // assert lock.getHoldCount() == 1;
        // assert items[putIndex] == null;
        //获取全局数组
        final Object[] items = this.items;
        //获取当前输入下标的值并赋值
        items[putIndex] = x;
        //当前下标等于数组长度重置为0
        if (++putIndex == items.length)
            putIndex = 0;
        //数据+1
        count++;
        //唤醒非空阻塞
        notEmpty.signal();
    }
```

```java
    public E take() throws InterruptedException {
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == 0)
                //空阻塞
                notEmpty.await();
            return dequeue();
        } finally {
            lock.unlock();
        }
    }
```

```java
    private E dequeue() {
        // assert lock.getHoldCount() == 1;
        // assert items[takeIndex] != null;
        final Object[] items = this.items;
        @SuppressWarnings("unchecked")
        //获取当前输出下标值
        E x = (E) items[takeIndex];
        //重置为空
        items[takeIndex] = null;
        if (++takeIndex == items.length)
            takeIndex = 0;
        count--;
        if (itrs != null)
            itrs.elementDequeued();
        //唤醒满阻塞
        notFull.signal();
        return x;
    }
```



