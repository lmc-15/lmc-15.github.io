### 通信方式

单工：数据当向传输。类似：遥控器

半双工：双方都可相互发送，同一时间只有一台服务可发送数据，也就是你要给我发
的话，也必须等我发给你完了之后才能给我发。类似：对讲机

全双工：数据的传输是双向，可同时传输。类似：打电话

mysql 数据 半双工

### SQL执行阶段

语法解析，预处理查看表或字段是否存在，语句优化，

（准备阶段）查询语句时预处理器判断是否存在字段或者表

优化阶段

执行阶段

### 数据持久

写记录会先卸载缓存和redo log，redo log 是来保证宕机后没被刷新到磁盘的是数据使用的，中然后Buff Pool 定时将Buff数据刷到磁盘，为什么要redo log 因为redo log 是顺序IO 性能比较好效率高。





redo来保证数据持久，undo 来保证数据异常回滚

### 存储引擎

5.5之前使用Myisam （利用索引，顺序存取数据的方法））

后只用innodb（支持事务，支持行级别的锁，对于业务一致性要求高的场景来说更适合。）

内存的缓冲池占满时InnoDB用LRU算法来管理缓冲池，淘汰热点数据。

InnoDB 一页 16K操作系统4K 所以读取一页需要4次IO

### 事务管理

#### 四大特性:ACID

- 原子性（Atomicity）

  对于一些列操作要么成功，要么都失败。失败了需要回滚，InnoDB 通过undo log来实现原子性，undo lod 记录了数据修改前的值，发送异常可以通过undo log 来进行回滚操作。

- 一致性（consistent）

  一致性一般再代码业务逻辑中控制。

- 隔离性（Isolation）

  多个事务同时操作同一张表或者同一行数据时，互不干扰，通过这种方式，保证业务数据最终一致性

- 持久性（Durable）

  就是服务器挂了或者重启，数据还能恢复原来的状态

### 事务带来问题

- 脏读

  通个事务读取两次结果不同，原因被其他事务中途修改了最后又做了回滚操作。
  
- 不可重复读

  通个事务读取两次结果不同，原因被其他事务中途修改了最后做了提交操作。

-   幻读

- 第一个事务查询时，第二个事务做了insert操作导致两次查询出语句条数不一致。

### 事务隔离级别

- 未提交读

  没解决任何事情

- 已提交读

  只读取已提交的内容，解决脏读

- 可重复读

  同一事务下多次读取都是一样的结果，解决不可重复读

- 串行化

  所有事务串行进行，解决所有问题

  | 事务隔离级别 | 脏读   | 不可重复度 | 幻读           |
  | ------------ | ------ | ---------- | -------------- |
  | 未提交读     | 可能   | 可能       | 可能           |
  | 已提交读     | 不可能 | 可能       | 可能           |
  | 可重复读     | 不可能 | 不可能     | 对InnoDB不可能 |
  | 串行化       | 不可能 | 不可能     | 不可能         |

  

### MVCC

MVCC核心思想：我们能查到事务开始前的数据，即使被其他事务增删改后也不影响当前事务

MVCC利用两个字段来实现` 创建版本号，删除版本号`

- 查找规则:只能查找创建时间小于等于当前事务ID的数据和删除时间大于当前事务ID的行

查询记录不存在使用间隙锁，间隙锁只针对insert，临建锁是一种特殊的间隙锁 + 记录所

### 数据库性能优化

- 修改最大连接数
- 调整释放不活动连接的时长
- 用连接池
- 引入缓存
- 读写分离（master写记录到binglog，master dump 线程将binglog发给slave，slave线程读relay 把数据写入数据库）
- 分库分表
- MQ进行萧峰

### BTree和B+Tree

#### 平衡多路查找树

InnoDB默认每页大小16K，可通过innodb_page_size设置

- B-Tree特性
  - 每个节点最多有m个孩子。
  - 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。 
  - 若根节点不是叶子节点，则至少有2个孩子 
  - 所有叶子节点都在同一层，且不包含其它关键字信息 
  - 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn） 
  - 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1
  - ki(i=1,…n)为关键字，且关键字升序排序。
  - Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)

- B-Tree如何查找
  - 根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】
  - 比较关键字在磁盘块哪个区间，找到磁盘块1的指针指向下一个磁盘块
  - 获取到磁盘块读到内存。【磁盘I/O操作第2次】（重复1的过程以此类推）

- B+Tree相对于B-Tree有几点不同:
  - 非叶子节点只存储键值信息
  - 所有叶子节点之间都有一个链指针。
  - 数据记录都存放在叶子节点中。

好处在一减少IO ，查找稳定









