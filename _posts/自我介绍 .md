你好，我叫刘名超，14年毕业于福建农林大学金山学院

16年重试计算机行业

目前在福州就业

16-18年在亚信软件承担后端开发工程师，在其期间支撑过新疆，云南，贵州的CRM2.9

并实施贵州2.9上线

Crm系统主要由前端、后端服务，配置中心服务，规则服务，权限系统组成，通过前台收集数据，后台将数据入缓存最后规则校验成功后将数据建档



数据采集平台主要是将不同医院不同的数据源汇总一起，并提供统一数据出口

18-至今在中电健康医疗大数据承担后端开发工程师，主要项目由数据采集平台，主要负责核心业务逻辑的设计以及开发，主要开发功能有，定时调度管理，配置中心，动态路由不同数据源，元数据变更管理，快速校验MD5等



我们系统主要将各个医院的数据采集到本地服务器并提供统一出口给用户使用，我们主要用户有保险公司，医疗机构，提供临床以学，科研成果等。我们系统主要分为两大区域，一个中心（本地服务器），前置机（主要部署在医院端的），中的有3大模块组成,流量调度服务（处理各个任务的调度管控），业务中心服务主要处理核心业务处理，文件服务主要是文件处理，前机制有文件服务，前置机采集服务主要是采集前机制数据。整个采集流程是业务中心生成采集任务，有调度中心下发任务，中心拼装报文派发到前置机采集服务，通过报文信息进行对数据采集，采集完成后对文件数据进行切割，压缩加密，后通知中心对文件数据进行持久化并由调度中心派发下载，中心下载完成后对数据解密解压计算MD5校验，校验通过后通过kafka发送消息到大数据端，

### 采集项目流程

有新的医院接入时，先将对该医院下的数据库进行元数据采集，并将元数据信息，以kafka的形式通知大数据平台，元数据准备完成后标记管控列后，将对医院数据进行采集，采集策略有，按天采集，按月采集，按ID采集，全表采集。通过不同的策略生成采集任务，生成任务的同时生成初始化任务脚本并将脚本入缓存，任务ID塞到队列，调动中心会轮询队列发现队列有数据则弹出ID通知中心并且信号量加+1（信号量记录在redis中），中心收到通知通过iD获取从缓存中获取脚本，获取不到则重新生成一份，中心将拼装好的报文，发送到前置机开始通过datax执行任务，生成文件，并通知中心结果修改任务状态，并减信号量，并将文件进行切割（切割大小可配置）计算MD5,压缩，加密，将文件信息同步中心，中心生成文件信息如表入队列，通过调度中心轮询，派发文件服务进行文件下载，文件下载，一致性校验完成解压后判断该任务下的所有文件是否已经下载完如果都下载完成通知中心该任务已经完成，可以通知大数据平台来获取数据了，后面大数据获取报文并对数行入库。

功能点介绍

定时调度管理

因为我们调度的模块有很多，比如采集任务调度，文件下载调度，影像任务调度，影像下载调度等，他们整体流程差不多，不过各个调度都有一些定制化的功能，所以我用到了策略模式加上模板模式，通过父类来制定模板，子类来实现不同的调度策略，通过重写来实现定制化。每个子类都有一个注解，注解主要配置有，发送接口的地址，调度频率，派发的模块，默认的总阈值，默认没家医院的阈值，在spring 启动时会扫描这些注解获取配置，通过反射的方法生成类信息，并且调用初始化方法将配置导入，并启动守护线程，根据设定的调度时间来轮询，查看队列是否有任务，有则通过线程池来发送这条任务到指定服务模块

配置中心

配置中心我们目前支持zookeepr，配置中心我们目前是通过Spring boot 自动装配的功能，启动时先读取带有MDA的这个注解，将MDA注解中的modules中的name作为key，Class作为value保存在Map容器中，读取配置，生成CuratorFramework，获取指定路劲下通过key获取一个集合，节点为FieldName ，value 为值，通过反射的方式将之前在对应在容器中的类来进行反射将在配置中心的值设置到java内存去，然后通过监听节点的 事件来再次触发反射操作

动态路由不同数据源

这个功能主要是操作不同数据库的JDBC操作，获取元数据用的，有共同点也有不同点，所以利用父类实现共同点，子类实现不同点，初始化时扫描注解，获取注解上的dataSourceName作为Key，对象为value保存在map容器中，当外部调用只需传一个dataBase对象里面包含数据库名称，地址，userNmae，passWord，port等信息，通过刚才类的接口可生成刚才容器中我们保存的对象来操作已经封装好的API

元数据变更管理



没接入一家新的医院我们都需要将医院的元数据信息通过kafka形式发送到大数据中心，确保大数据在下载文件的同时值的字段和顺序能对应上，此时医院元素发生变更，比如表新加了字段或者修改这段，这是我们就要触发一条消息来通知大数据。



快速校验MD5等



在下载影像的过程中我们发现有部分影像其实是影片，非常大，大概好几G这样子，所以在计算MD5的时候影响效率这时我们采取的策略是当文件大于一定的阈值时只校验头部和尾部指定字节大小，通过自己计算MD5我们用的时JDK自带的MessageDigest messagedigest，在初始化的时候生成，因为他是线程不安全，所以需要枷锁，但是加锁时在高并发会影响效率，所以初始化的时候我们生成了10个MessageDigest 放在数组里，每次枷锁会在这个数组里随机抽取一个来进行枷锁和使用
